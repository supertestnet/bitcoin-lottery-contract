# Bitcoin lottery contract
A lottery in bitcoin script with no escrow, based on random number generation and modular arithmetic

This is a series of smart contracts that allow multiple parties to participate in a fair bitcoin lottery. 2, 3, 4, or 5 players can play. Each player deposits an agreed-upon amount of money into a bitcoin smart contract and only one randomly selected party gets to withdraw the total amount.

# Random number generation

A random number is generated by taking a seed from each player, specifically a number 0 through N-1 (where N is the number of players), summing the seeds selected by all players, and then doing modular arithmetic on the sum over a finite field from 0 through N-1. The result is a random number from 0 through N-1 that no party could predict in advance unless they know all the choices made by every other party. This random number is then used as the basis for withdrawal logic: if the random number is 0, player 1 gets to withdraw; if it is 1, player 2 gets to withdraw, etc.

# Random numbers? I thought bitcoin script couldn't do random number generation

It can. Bitcoin script can do modular arithmetic and take inputs from multiple parties. That's all you need to generate random numbers, so bitcoin script can generate random numbers.

# But modular arithmetic requires loops! Bitcoin script doesn't have loops!

You don't need loops to do modular arithmetic if you can copy/paste a function a bunch of times. I wrote a small function that compares X to Y and does some subtraction if X is greater than Y. Then I repeat that as many times as there are players, and voila, the result is modular arithmetic without loops.

# Wait you said every player has to provide a seed. How do you enforce that?

Through hashed timelocked contracts. Before the game, the players each pick random a byte string that is at least 16 bytes long and send the hash of their string to the other players. They then must deposit money into a hashed timelocked contract where they only get the money back if they reveal the bytestring they chose. The length of the bytestring encodes the number they picked: if it is 16 bytes, they picked a 0. If it is 17 bytes, they picked a 1, etc. Also, the amount of money they put into this HTLC is equal to the amount needed to make every other player a winner; if any player doesn't reveal their preimage via the htlc, the sats they put up as collateral go to the other players, thus making everyone a winner except the one person who chose not to reveal their preimage. A good consequence of this design is that each players only has one way to not lose: they must reveal the number they picked. If they don't, every other player becomes a winner.

# Someone said this project also involves a coinjoin. What's up with that?

Yeah, one of the things I needed to do was make sure everyone in the game sends their money into the lottery address and the collateral addresses at the same time. The only way I know how to do that is with a coinjoin, so I wrote some coinjoin software to enable that. It's included in the index.html file.

# Wait there's a coinjoin in javascript??

Yep.

# SERIOUSLY??!?

Yes.

# Who is the coordinator?

The short answer is: I alphabetize the players' pubkeys and choose the "highest" pubkey as the coordinator. I wish I could say there is no coordinator, but that's not quite true. I did manage to reduce the role of the coordinator compared to some other coinjoin software, but at a significant cost: the coordinator's only roles are to cosign the coinjoin and publish its final state, which is not much of a coordinative role, but the downside is that -- to reduce it this far -- I have every player tell their utxo data to every other player, including the coordinator. In most other coinjoin software, the coordinator is the only one who learns in advance which utxos will be part of a particular coinjoin. Here, everyone involved learns that information, so it's not as privacy preserving as other coinjoin software. Still, the coordinator is just another player, and the coordination is minimal, which means (I hope) the coordinator doesn't need to take a fee for their service. That should make this coinjoin software cheaper than other coinjoin software.

# How can I play?

It's really hard to play right now. There is no user interface yet and everything happens in the browser console. It requires multiple tabs to be open, it requires a regtest node and mempool.space to be running on your device and listening for api calls on localhost:4200, and what's worse, multiple players have to coordinate in advance so that they type the same things into the initial fields, and what's even more worser, they also have to copy/paste a bunch of things and format a bunch of things and it's a serious pain. I'm working on it. But the coinjoin logic works and so does the lottery! You can actually do real coinjoins and lottery games with this and I'm very excited to put it out on github while I iron out the UI kinks -- and eventually, hopefully, put it on mainnet. Stay tuned for more.
